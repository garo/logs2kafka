package main

import "github.com/Jeffail/gabs"
import "github.com/buger/jsonparser"

//import "strconv"
import "time"
import "strings"
import "fmt"
import "bytes"

type ServerInfo struct {
	Hostname string
	ServerIP string
}

type Message struct {
	Topic     string
	Data      []byte
	Container *gabs.Container
}

var validLevels = [...]string{
	"DEBUG",
	"INFO",
	"WARN",
	"ERROR",
}

var docker_left_names = [...]string{
	"admiring_",
	"adoring_",
	"agitated_",
	"amazing_",
	"angry_",
	"awesome_",
	"backstabbing_",
	"berserk_",
	"big_",
	"boring_",
	"clever_",
	"cocky_",
	"compassionate_",
	"condescending_",
	"cranky_",
	"desperate_",
	"determined_",
	"distracted_",
	"dreamy_",
	"drunk_",
	"ecstatic_",
	"elated_",
	"elegant_",
	"evil_",
	"fervent_",
	"focused_",
	"furious_",
	"gigantic_",
	"gloomy_",
	"goofy_",
	"grave_",
	"happy_",
	"high_",
	"hopeful_",
	"hungry_",
	"infallible_",
	"jolly_",
	"jovial_",
	"kickass_",
	"lonely_",
	"loving_",
	"mad_",
	"modest_",
	"naughty_",
	"nauseous_",
	"nostalgic_",
	"pedantic_",
	"pensive_",
	"prickly_",
	"reverent_",
	"romantic_",
	"sad_",
	"serene_",
	"sharp_",
	"sick_",
	"silly_",
	"sleepy_",
	"small_",
	"stoic_",
	"stupefied_",
	"suspicious_",
	"tender_",
	"thirsty_",
	"tiny_",
	"trusting_",
}

func JSONToMessage(str string) Message {
	//fmt.Printf("JSONToMessage: %+v\n", str)
	m := Message{}

	m.Data = []byte(str)

	return m
}

func (m *Message) ParseJSON() error {

	if m.Container != nil {
		return nil
	}

	parsedJson, err := gabs.ParseJSON(m.Data)
	if err != nil {
		return err
	}

	m.Container = parsedJson

	return nil
}

func (m *Message) GetString(keys ...string) (string, error) {

	v, t, _, e := jsonparser.Get(m.Data, keys...)

	if e != nil {
		return "", e
	}

	if t != jsonparser.String {
		return "", fmt.Errorf("Value is not a number: %s", string(v))
	}

	// If no escapes return raw conten
	if bytes.IndexByte(v, '\\') == -1 {
		return string(v), nil
	}

	m.ParseJSON()
	value, _ := m.Container.Path(strings.Join(keys, ".")).Data().(string)
	return value, nil
}

func EnsureMessageFormat(i ServerInfo, m *Message) error {
	err := EnsureMessageTimestamp(m)
	if err != nil {
		return err
	}

	err = EnsureMessageLevel(m)
	if err != nil {
		return err
	}

	err = EnsureMessageService(m)
	if err != nil {
		return err
	}

	err = EnsureMessageServiceServerInfo(i, m)
	if err != nil {
		return err
	}

	return nil
}

func EnsureMessageTimestamp(m *Message) error {

	_, ok := m.Container.Path("ts").Data().(string)
	if !ok {
		ts := time.Now().UTC().Format(time.RFC3339Nano)

		m.Container.Set(ts, "ts")
	}

	return nil
}

// Logic:
// First select service name using following rules
//   1) Use 'service' if present
//   2) Use container_name BUT only if it's not an autogenerated name
//
// Then:
//   1) Set 'service' field to service name if it's not already set
//   2) Set m.Topic to the service name
func EnsureMessageService(m *Message) error {

	service, ok := m.Container.Path("service").Data().(string)

	if ok {
		m.Topic = service
		return nil
	} 

	kubernetes_container_name, ok := m.Container.Search("_io.kubernetes.container.name").Data().(string)

	if ok {
		m.Container.Set(kubernetes_container_name, "service")
		m.Topic = kubernetes_container_name
	} else {
		container_name, ok := m.Container.Path("container_name").Data().(string)
		if ok {

			match := false
			for _, prefix := range docker_left_names {
				if strings.HasPrefix(container_name, prefix) {
					match = true
					break
				}
			}
			if !match {
				m.Container.Set(container_name, "service")
				m.Topic = container_name
			}
		}
	}
	return nil
}

func EnsureMessageLevel(m *Message) error {

	value, ok := m.Container.Path("level").Data().(string)
	if ok {
		if upperCaseValue := strings.ToUpper(value); upperCaseValue != value {
			m.Container.Set(upperCaseValue, "level")
			value = upperCaseValue
		}

		found := false
		for i := 0; i < len(validLevels); i++ {
			if validLevels[i] == value {
				found = true
			}
		}

		if value == "WARNING" {
			m.Container.Set("WARN", "level")
			found = true
		}

		if !found {
			m.Container.Set("UNKNOWN", "level")
		}
	}
	return nil
}

func EnsureMessageServiceServerInfo(i ServerInfo, m *Message) error {
	if i.Hostname != "" {
		_, ok := m.Container.Path("host").Data().(string)
		if !ok {
			m.Container.Set(i.Hostname, "host")
		}
	}

	if i.ServerIP != "" {
		m.Container.Set(i.ServerIP, "server_ip")
	}

	return nil
}
